### Задания к занятию 3
* Определение и вызов методов
* Параметры и аргументы
* Возвращаемое значение
* Объектно-Ориентированное Программирование
* Определение собственных типов данных (классов)
#### 1. Методы Ruby Core API
Найдите в документации Ruby по адресу http://ruby-doc.org/core/ методы для объектов разных классов. Поэкспериментируйте с ними в интерактивной оболочке `irb`
Для класса `Hash`:
* Метод, принимающий блок и удаляющий пару, если условие внутри блока вычисляется в `true` delete_if
* Метод, проверяющий пуст ли хэш empty?
* Метод, принимающий аргументы переменной длины, каждый из которых является ключом хэша. Если удаётся последовательно получить значение для каждого из ключей, возвращается это значение. Если нет - возвращается `nil`. Трудно объяснить метод словами, поэтому ниже пример:
```ruby
storage = { data: { name: 'John' } }
storage.<method>(:data, :name) # => 'John'
storage.<method>(:data, :age)  # => nil
``` dig
Для класса `Symbol`:
* Метод, возвращающий массив всех определённых символов в памяти на данный момент all_symbols
* Метод, проверяющий находится ли зданное имя символа между двумя другими заданными именами символов. Между – имеется в виду проверка по кодам ASCII для символов из которых состоит объект класса `Symbol` sym[b, n]
Для класса `File`:
* Метод, превращающий путь к файлу в его абсолютный путь expand_path
* Метод проверяющий, является ли данный файл каталогом directory?
* Метод проверяющий существование файла exist?
* Метод возвращающий время модификации файла ctime
Для класса `Time`:
* Метод, возвращающий текущее время now
* Метод, проверяющий пятница ли сегодня friday?
* Метод, возвращающий строку с названием часового пояса zone
Для модуля `Kernel`:
* Метод, возволяющий исполнять любой Ruby код, переданный в качестве строки eval
* Метод, позволяющий приостановить работу программы на определённое количество секунд sleep
#### 2. Сколько здесь вариантов?
Напишите метод `combination` для поиска [сочетаний] в массиве элементов. Сравните производительность метода с одноимённым методом Ruby из класса `Array` при помощи модуля `Benchmark`. Пример:
```ruby
elements = [:one, :two, :three, :four]
combination elements, 2 # => [[:one, :two], [:one, :three], [:one, :four], [:two, :three], [:two, :four], [:three, :four]]
```
В качестве дополнительной тренировки модифицируйте ваш метод таким образом, чтобы он принимал переменное количество аргументов:
```ruby
combination :one, :two, :three, :four, group_size: 2
```
Вариант 1
elements = [:one, :two, :three, :four]
result = []
(0 ... elements.length).map do |i|
 
    (i ... elements.length).map do |j|
        
        unless i == j
            result.push ([elements[i], elements[j]])
            j+=1
        end
          
  end
    
end
puts "#{result}"
Вариант 2
elements = [:one, :two, :three, :four]

elements = elements.combination(2).to_a
puts "#{elements}"
elements = [:one, :two, :three, :four]

В качестве дополнительной тренировки модифицируйте ваш метод таким образом, чтобы он принимал переменное количество аргументов:

def combination(array)
result = []
(0 ... array.length).map do |i|
 
    (i ... array.length).map do |j|
        
        unless i == j
            result.push ([array[i], array[j]])
            j+=1
        end
          
  end
    
end
return results
end
combination(elements)
puts "#{result}"

#### 3. Собственный тип данных
Подумайте над любой задачей из реального мира, определите сущности и попробуйте представить их с помощью типов данных Ruby. Для каких сущностей вы определили собственные классы и почему?


#### 4. ООП в движении
Понаблюдайте и попробуйте описать (в виде свободного текста) процесс взаимодействия между объектами по аналогии с примером продавца. Постарайтесь чётко обозначить какие объекты участвуют во взаимодействии, каким поведением (методами) они обладают и каким состоянием (данными), какие методы вызываются в процессе взаимодействия.

1.Наследование. Возьмем повара на кухне. На кухне есть 2 печки электрическая и газовая. 

Попробуем описать процесс приготовления пищи поваром в каждой из печи. 

Берем любую кухонную печь (абстрактную печь). У нее есть поведение — включить, выключить, увеличить или уменьшить температуру и состояние — температура в печи, включена или выключена. И есть повар, конкретный повар. Он умеет работать с абстрактной печью. Т.е. смотреть температуру, включать выключать и т.д. Наследуя знания от класса абстрактной печи нам не придется обучать повара для работы с какой то конкретной печью электрической или газовой т.е. он может смотреть температуру, включать выключать и т.д., любую из этих печей.

2. Полиморфизм. Печи работают по разному. Газовая работает на газу, электрическая печь на  электричестве. Печи являются наследниками абстрактной печи, а так как у них разный принцип работы, мы меняем поведение наследников абстрактной печи.

3. Инкапсуляция. Повар не должен знать, что происходит внутри печи. Повар вызывает не метод включить печь, а меняет ее свойство - на значение включена. Если принцип инкапсуляции не соблюден, повар вынужден будет сказать печи, что бы она начала потреблять горючее, т.к. он ее включил.

### Контакты для связи
* [GeekBrains](http://geekbrains.ru)
* Электронная почта: `spaceflow@gmail.com`
* [Slack](http://geekbrainsruby.slack.com) канал
<!-- Links -->
[сочетаний]: https://ru.wikipedia.org/wiki/Сочетание
